/**
 * Autogenerated by Thrift Compiler (0.8.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef AuditEvent_H
#define AuditEvent_H

#include <TProcessor.h>
#include "auditevent_types.h"



class AuditEventIf {
 public:
  virtual ~AuditEventIf() {}
  virtual void store(const Message& msg) = 0;
  virtual void heartbeat(const int16_t server_id, const std::string& token) = 0;
};

class AuditEventIfFactory {
 public:
  typedef AuditEventIf Handler;

  virtual ~AuditEventIfFactory() {}

  virtual AuditEventIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(AuditEventIf* /* handler */) = 0;
};

class AuditEventIfSingletonFactory : virtual public AuditEventIfFactory {
 public:
  AuditEventIfSingletonFactory(const boost::shared_ptr<AuditEventIf>& iface) : iface_(iface) {}
  virtual ~AuditEventIfSingletonFactory() {}

  virtual AuditEventIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(AuditEventIf* /* handler */) {}

 protected:
  boost::shared_ptr<AuditEventIf> iface_;
};

class AuditEventNull : virtual public AuditEventIf {
 public:
  virtual ~AuditEventNull() {}
  void store(const Message& /* msg */) {
    return;
  }
  void heartbeat(const int16_t /* server_id */, const std::string& /* token */) {
    return;
  }
};

typedef struct _AuditEvent_store_args__isset {
  _AuditEvent_store_args__isset() : msg(false) {}
  bool msg;
} _AuditEvent_store_args__isset;

class AuditEvent_store_args {
 public:

  AuditEvent_store_args() {
  }

  virtual ~AuditEvent_store_args() throw() {}

  Message msg;

  _AuditEvent_store_args__isset __isset;

  void __set_msg(const Message& val) {
    msg = val;
  }

  bool operator == (const AuditEvent_store_args & rhs) const
  {
    if (!(msg == rhs.msg))
      return false;
    return true;
  }
  bool operator != (const AuditEvent_store_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuditEvent_store_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AuditEvent_store_pargs {
 public:


  virtual ~AuditEvent_store_pargs() throw() {}

  const Message* msg;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AuditEvent_store_result {
 public:

  AuditEvent_store_result() {
  }

  virtual ~AuditEvent_store_result() throw() {}


  bool operator == (const AuditEvent_store_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const AuditEvent_store_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuditEvent_store_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AuditEvent_store_presult {
 public:


  virtual ~AuditEvent_store_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _AuditEvent_heartbeat_args__isset {
  _AuditEvent_heartbeat_args__isset() : server_id(false), token(false) {}
  bool server_id;
  bool token;
} _AuditEvent_heartbeat_args__isset;

class AuditEvent_heartbeat_args {
 public:

  AuditEvent_heartbeat_args() : server_id(0), token("") {
  }

  virtual ~AuditEvent_heartbeat_args() throw() {}

  int16_t server_id;
  std::string token;

  _AuditEvent_heartbeat_args__isset __isset;

  void __set_server_id(const int16_t val) {
    server_id = val;
  }

  void __set_token(const std::string& val) {
    token = val;
  }

  bool operator == (const AuditEvent_heartbeat_args & rhs) const
  {
    if (!(server_id == rhs.server_id))
      return false;
    if (!(token == rhs.token))
      return false;
    return true;
  }
  bool operator != (const AuditEvent_heartbeat_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuditEvent_heartbeat_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AuditEvent_heartbeat_pargs {
 public:


  virtual ~AuditEvent_heartbeat_pargs() throw() {}

  const int16_t* server_id;
  const std::string* token;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AuditEvent_heartbeat_result {
 public:

  AuditEvent_heartbeat_result() {
  }

  virtual ~AuditEvent_heartbeat_result() throw() {}


  bool operator == (const AuditEvent_heartbeat_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const AuditEvent_heartbeat_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AuditEvent_heartbeat_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class AuditEvent_heartbeat_presult {
 public:


  virtual ~AuditEvent_heartbeat_presult() throw() {}


  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class AuditEventClient : virtual public AuditEventIf {
 public:
  AuditEventClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  AuditEventClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void store(const Message& msg);
  void send_store(const Message& msg);
  void recv_store();
  void heartbeat(const int16_t server_id, const std::string& token);
  void send_heartbeat(const int16_t server_id, const std::string& token);
  void recv_heartbeat();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class AuditEventProcessor : public ::apache::thrift::TProcessor {
 protected:
  boost::shared_ptr<AuditEventIf> iface_;
  virtual bool process_fn(apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, std::string& fname, int32_t seqid, void* callContext);
 private:
  std::map<std::string, void (AuditEventProcessor::*)(int32_t, apache::thrift::protocol::TProtocol*, apache::thrift::protocol::TProtocol*, void*)> processMap_;
  void process_store(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_heartbeat(int32_t seqid, apache::thrift::protocol::TProtocol* iprot, apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  AuditEventProcessor(boost::shared_ptr<AuditEventIf> iface) :
    iface_(iface) {
    processMap_["store"] = &AuditEventProcessor::process_store;
    processMap_["heartbeat"] = &AuditEventProcessor::process_heartbeat;
  }

  virtual bool process(boost::shared_ptr<apache::thrift::protocol::TProtocol> piprot, boost::shared_ptr<apache::thrift::protocol::TProtocol> poprot, void* callContext);
  virtual ~AuditEventProcessor() {}
};

class AuditEventProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  AuditEventProcessorFactory(const ::boost::shared_ptr< AuditEventIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< AuditEventIfFactory > handlerFactory_;
};

class AuditEventMultiface : virtual public AuditEventIf {
 public:
  AuditEventMultiface(std::vector<boost::shared_ptr<AuditEventIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~AuditEventMultiface() {}
 protected:
  std::vector<boost::shared_ptr<AuditEventIf> > ifaces_;
  AuditEventMultiface() {}
  void add(boost::shared_ptr<AuditEventIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void store(const Message& msg) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->store(msg);
    }
  }

  void heartbeat(const int16_t server_id, const std::string& token) {
    size_t sz = ifaces_.size();
    for (size_t i = 0; i < sz; ++i) {
      ifaces_[i]->heartbeat(server_id, token);
    }
  }

};



#endif
